import type { Binding } from '@babel/traverse';
import * as t from '@babel/types';
import * as m from '@codemod/matchers';
import { applyTransform, renameFast, renameParameters } from '../../ast-utils';
import { constMemberExpression } from '../../ast-utils/matcher';
import { Module } from '../module';
import type { FunctionPath } from './common-matchers';
import { ImportExportManager } from './import-export-manager';
import { transformJsonModule } from './json-module';
import { default as definePropertyGetters } from './runtime/define-property-getters';
import getDefaultExport from './runtime/get-default-export';
import global from './runtime/global';
import hasOwnProperty from './runtime/has-own-property';
import moduleDecorator from './runtime/module-decorator';
import namespaceObject from './runtime/namespace-object';
import varInjections from './var-injections';

export class WebpackModule extends Module {
  /**
   * Module ids that are imported by this module.
   */
  imports: Set<string>;

  #manager: ImportExportManager;
  #moduleBinding: Binding | undefined;
  #exportsBinding: Binding | undefined;
  #webpackRequireBinding: Binding | undefined;
  #sourceType: 'commonjs' | 'esm' | 'json' = 'commonjs';
  #json: unknown;
  /**
   * The module name of a re-exported dependency.
   * https://webpack.js.org/configuration/externals
   * @internal
   */
  externalModule?: string;

  constructor(id: string, ast: FunctionPath, isEntry: boolean) {
    // TODO: refactor
    const file = t.file(t.program(ast.node.body.body));
    super(id, file, isEntry);

    this.removeTrailingComments();
    // The params are temporarily renamed to these special names to avoid
    // mixing them up with the global module/exports/require from Node.js
    renameParameters(ast, [
      '__webpack_module__',
      '__webpack_exports__',
      '__webpack_require__',
    ]);
    this.#moduleBinding = ast.scope.getOwnBinding('__webpack_module__');
    this.#webpackRequireBinding = ast.scope.getOwnBinding('__webpack_require__');
    this.#exportsBinding = ast.scope.getOwnBinding('__webpack_exports__');

    const manager = new ImportExportManager(file, this.#webpackRequireBinding);
    this.#manager = manager;
    this.imports = new Set(manager.requireCalls.map((call) => call.moduleId));

    this.externalModule = this.detectExternalModule();
    const json = transformJsonModule(this.ast);
    if (json) {
      this.#sourceType = 'json';
      this.#json = json;
      this.path = this.path.replace(/\.js$/, '.json');
    }
  }

  applyTransforms(resolve: (moduleId: string) => string): void {
    applyTransform(this.ast, varInjections);
    applyTransform(this.ast, global, this.#webpackRequireBinding);
    applyTransform(this.ast, hasOwnProperty, this.#webpackRequireBinding);
    applyTransform(this.ast, moduleDecorator, this.#webpackRequireBinding);
    applyTransform(this.ast, namespaceObject);
    applyTransform(this.ast, getDefaultExport, this.#manager);
    applyTransform(this.ast, definePropertyGetters, this.#manager);
    this.#manager.insertImportsAndExports(resolve);
    this.removeDefineESM();

    if (this.#moduleBinding) renameFast(this.#moduleBinding, 'module');
    if (this.#exportsBinding) renameFast(this.#exportsBinding, 'exports');
  }

  override get code() {
    return this.#sourceType === 'json'
      ? JSON.stringify(this.#json, null, 2)
      : super.code;
  }

  /**
   * Remove /***\/ comments between modules (in webpack development builds)
   */
  private removeTrailingComments(): void {
    const lastNode = this.ast.program.body.at(-1);
    if (
      lastNode?.trailingComments &&
      lastNode.trailingComments.length >= 1 &&
      lastNode.trailingComments.at(-1)!.value === '*'
    ) {
      lastNode.trailingComments.pop();
    }
  }

  private detectExternalModule(): string | undefined {
    const moduleName = m.capture(m.anyString());
    const matcher = m.program([
      m.expressionStatement(
        m.assignmentExpression(
          '=',
          constMemberExpression('__webpack_module__', 'exports'),
          m.callExpression(m.identifier('require'), [
            m.stringLiteral(moduleName),
          ]),
        ),
      ),
    ]);
    if (matcher.match(this.ast.program)) {
      return moduleName.current!;
    }
  }

  /**
   * Remove `Object.defineProperty(exports, "__esModule", { value: true });`
   * This is most likely generated by TypeScript.
   */
  private removeDefineESM(): void {
    const matcher = m.expressionStatement(
      m.callExpression(constMemberExpression('Object', 'defineProperty'), [
        m.identifier(),
        m.stringLiteral('__esModule'),
        m.objectExpression([
          m.objectProperty(m.identifier('value'), m.booleanLiteral(true)),
        ]),
      ]),
    );

    for (let i = 0; i < this.ast.program.body.length; i++) {
      const node = this.ast.program.body[i];
      if (matcher.match(node)) {
        this.#sourceType = 'esm';
        this.ast.program.body.splice(i, 1);
        i--;
      }
    }
  }
}
