// This file is generated by scripts/build.ts. Do not edit manually.
import type * as t from '@babel/types';
import type { NodeSchema, Schema } from './types.js';

export function anyTypeAnnotation(): NodeSchema<t.AnyTypeAnnotation> {
  return { type: 'AnyTypeAnnotation',  };
}
export function argumentPlaceholder(): NodeSchema<t.ArgumentPlaceholder> {
  return { type: 'ArgumentPlaceholder',  };
}
export function arrayExpression(elements?: Schema<Array<null | t.Expression | t.SpreadElement>>): NodeSchema<t.ArrayExpression> {
  return { type: 'ArrayExpression', elements };
}
export function arrayPattern(elements?: Schema<Array<null | t.PatternLike | t.LVal>>): NodeSchema<t.ArrayPattern> {
  return { type: 'ArrayPattern', elements };
}
export function arrayTypeAnnotation(elementType?: Schema<t.FlowType>): NodeSchema<t.ArrayTypeAnnotation> {
  return { type: 'ArrayTypeAnnotation', elementType };
}
export function arrowFunctionExpression(params?: Schema<Array<t.Identifier | t.Pattern | t.RestElement>>, body?: Schema<t.BlockStatement | t.Expression>, async?: Schema<boolean>): NodeSchema<t.ArrowFunctionExpression> {
  return { type: 'ArrowFunctionExpression', params, body, async };
}
export function assignmentExpression(operator?: Schema<string>, left?: Schema<t.LVal | t.OptionalMemberExpression>, right?: Schema<t.Expression>): NodeSchema<t.AssignmentExpression> {
  return { type: 'AssignmentExpression', operator, left, right };
}
export function assignmentPattern(left?: Schema<t.Identifier | t.ObjectPattern | t.ArrayPattern | t.MemberExpression | t.TSAsExpression | t.TSSatisfiesExpression | t.TSTypeAssertion | t.TSNonNullExpression>, right?: Schema<t.Expression>): NodeSchema<t.AssignmentPattern> {
  return { type: 'AssignmentPattern', left, right };
}
export function awaitExpression(argument?: Schema<t.Expression>): NodeSchema<t.AwaitExpression> {
  return { type: 'AwaitExpression', argument };
}
export function bigIntLiteral(value?: Schema<string>): NodeSchema<t.BigIntLiteral> {
  return { type: 'BigIntLiteral', value };
}
export function binaryExpression(operator?: Schema<"+" | "-" | "/" | "%" | "*" | "**" | "&" | "|" | ">>" | ">>>" | "<<" | "^" | "==" | "===" | "!=" | "!==" | "in" | "instanceof" | ">" | "<" | ">=" | "<=" | "|>">, left?: Schema<t.Expression | t.PrivateName>, right?: Schema<t.Expression>): NodeSchema<t.BinaryExpression> {
  return { type: 'BinaryExpression', operator, left, right };
}
export function bindExpression(object?: Schema<t.Expression>, callee?: Schema<t.Expression>): NodeSchema<t.BindExpression> {
  return { type: 'BindExpression', object, callee };
}
export function blockStatement(body?: Schema<Array<t.Statement>>, directives?: Schema<Array<t.Directive>>): NodeSchema<t.BlockStatement> {
  return { type: 'BlockStatement', body, directives };
}
export function booleanLiteral(value?: Schema<boolean>): NodeSchema<t.BooleanLiteral> {
  return { type: 'BooleanLiteral', value };
}
export function booleanLiteralTypeAnnotation(value?: Schema<boolean>): NodeSchema<t.BooleanLiteralTypeAnnotation> {
  return { type: 'BooleanLiteralTypeAnnotation', value };
}
export function booleanTypeAnnotation(): NodeSchema<t.BooleanTypeAnnotation> {
  return { type: 'BooleanTypeAnnotation',  };
}
export function breakStatement(label?: Schema<t.Identifier | null>): NodeSchema<t.BreakStatement> {
  return { type: 'BreakStatement', label };
}
export function callExpression(callee?: Schema<t.Expression | t.Super | t.V8IntrinsicIdentifier>, _arguments?: Schema<Array<t.Expression | t.SpreadElement | t.ArgumentPlaceholder>>): NodeSchema<t.CallExpression> {
  return { type: 'CallExpression', callee, arguments: _arguments };
}
export function catchClause(param?: Schema<t.Identifier | t.ArrayPattern | t.ObjectPattern | null>, body?: Schema<t.BlockStatement>): NodeSchema<t.CatchClause> {
  return { type: 'CatchClause', param, body };
}
export function classAccessorProperty(key?: Schema<t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral | t.Expression | t.PrivateName>, value?: Schema<t.Expression | null>, typeAnnotation?: Schema<t.TypeAnnotation | t.TSTypeAnnotation | t.Noop | null>, decorators?: Schema<Array<t.Decorator> | null>, computed?: Schema<boolean>, _static?: Schema<boolean>): NodeSchema<t.ClassAccessorProperty> {
  return { type: 'ClassAccessorProperty', key, value, typeAnnotation, decorators, computed, static: _static };
}
export function classBody(body?: Schema<Array<t.ClassMethod | t.ClassPrivateMethod | t.ClassProperty | t.ClassPrivateProperty | t.ClassAccessorProperty | t.TSDeclareMethod | t.TSIndexSignature | t.StaticBlock>>): NodeSchema<t.ClassBody> {
  return { type: 'ClassBody', body };
}
export function classDeclaration(id?: Schema<t.Identifier | null>, superClass?: Schema<t.Expression | null>, body?: Schema<t.ClassBody>, decorators?: Schema<Array<t.Decorator> | null>): NodeSchema<t.ClassDeclaration> {
  return { type: 'ClassDeclaration', id, superClass, body, decorators };
}
export function classExpression(id?: Schema<t.Identifier | null>, superClass?: Schema<t.Expression | null>, body?: Schema<t.ClassBody>, decorators?: Schema<Array<t.Decorator> | null>): NodeSchema<t.ClassExpression> {
  return { type: 'ClassExpression', id, superClass, body, decorators };
}
export function classImplements(id?: Schema<t.Identifier>, typeParameters?: Schema<t.TypeParameterInstantiation | null>): NodeSchema<t.ClassImplements> {
  return { type: 'ClassImplements', id, typeParameters };
}
export function classMethod(kind?: Schema<"get" | "set" | "method" | "constructor">, key?: Schema<t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral | t.Expression>, params?: Schema<Array<t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty>>, body?: Schema<t.BlockStatement>, computed?: Schema<boolean>, _static?: Schema<boolean>, generator?: Schema<boolean>, async?: Schema<boolean>): NodeSchema<t.ClassMethod> {
  return { type: 'ClassMethod', kind, key, params, body, computed, static: _static, generator, async };
}
export function classPrivateMethod(kind?: Schema<"get" | "set" | "method">, key?: Schema<t.PrivateName>, params?: Schema<Array<t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty>>, body?: Schema<t.BlockStatement>, _static?: Schema<boolean>): NodeSchema<t.ClassPrivateMethod> {
  return { type: 'ClassPrivateMethod', kind, key, params, body, static: _static };
}
export function classPrivateProperty(key?: Schema<t.PrivateName>, value?: Schema<t.Expression | null>, decorators?: Schema<Array<t.Decorator> | null>, _static?: Schema<boolean>): NodeSchema<t.ClassPrivateProperty> {
  return { type: 'ClassPrivateProperty', key, value, decorators, static: _static };
}
export function classProperty(key?: Schema<t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral | t.Expression>, value?: Schema<t.Expression | null>, typeAnnotation?: Schema<t.TypeAnnotation | t.TSTypeAnnotation | t.Noop | null>, decorators?: Schema<Array<t.Decorator> | null>, computed?: Schema<boolean>, _static?: Schema<boolean>): NodeSchema<t.ClassProperty> {
  return { type: 'ClassProperty', key, value, typeAnnotation, decorators, computed, static: _static };
}
export function conditionalExpression(test?: Schema<t.Expression>, consequent?: Schema<t.Expression>, alternate?: Schema<t.Expression>): NodeSchema<t.ConditionalExpression> {
  return { type: 'ConditionalExpression', test, consequent, alternate };
}
export function continueStatement(label?: Schema<t.Identifier | null>): NodeSchema<t.ContinueStatement> {
  return { type: 'ContinueStatement', label };
}
export function debuggerStatement(): NodeSchema<t.DebuggerStatement> {
  return { type: 'DebuggerStatement',  };
}
export function decimalLiteral(value?: Schema<string>): NodeSchema<t.DecimalLiteral> {
  return { type: 'DecimalLiteral', value };
}
export function declareClass(id?: Schema<t.Identifier>, typeParameters?: Schema<t.TypeParameterDeclaration | null>, _extends?: Schema<Array<t.InterfaceExtends> | null>, body?: Schema<t.ObjectTypeAnnotation>): NodeSchema<t.DeclareClass> {
  return { type: 'DeclareClass', id, typeParameters, extends: _extends, body };
}
export function declareExportAllDeclaration(source?: Schema<t.StringLiteral>, attributes?: Schema<Array<t.ImportAttribute> | null>): NodeSchema<t.DeclareExportAllDeclaration> {
  return { type: 'DeclareExportAllDeclaration', source, attributes };
}
export function declareExportDeclaration(declaration?: Schema<t.Flow | null>, specifiers?: Schema<Array<t.ExportSpecifier | t.ExportNamespaceSpecifier> | null>, source?: Schema<t.StringLiteral | null>, attributes?: Schema<Array<t.ImportAttribute> | null>): NodeSchema<t.DeclareExportDeclaration> {
  return { type: 'DeclareExportDeclaration', declaration, specifiers, source, attributes };
}
export function declareFunction(id?: Schema<t.Identifier>): NodeSchema<t.DeclareFunction> {
  return { type: 'DeclareFunction', id };
}
export function declareInterface(id?: Schema<t.Identifier>, typeParameters?: Schema<t.TypeParameterDeclaration | null>, _extends?: Schema<Array<t.InterfaceExtends> | null>, body?: Schema<t.ObjectTypeAnnotation>): NodeSchema<t.DeclareInterface> {
  return { type: 'DeclareInterface', id, typeParameters, extends: _extends, body };
}
export function declareModule(id?: Schema<t.Identifier | t.StringLiteral>, body?: Schema<t.BlockStatement>, kind?: Schema<"CommonJS" | "ES" | null>): NodeSchema<t.DeclareModule> {
  return { type: 'DeclareModule', id, body, kind };
}
export function declareModuleExports(typeAnnotation?: Schema<t.TypeAnnotation>): NodeSchema<t.DeclareModuleExports> {
  return { type: 'DeclareModuleExports', typeAnnotation };
}
export function declareOpaqueType(id?: Schema<t.Identifier>, typeParameters?: Schema<t.TypeParameterDeclaration | null>, supertype?: Schema<t.FlowType | null>): NodeSchema<t.DeclareOpaqueType> {
  return { type: 'DeclareOpaqueType', id, typeParameters, supertype };
}
export function declareTypeAlias(id?: Schema<t.Identifier>, typeParameters?: Schema<t.TypeParameterDeclaration | null>, right?: Schema<t.FlowType>): NodeSchema<t.DeclareTypeAlias> {
  return { type: 'DeclareTypeAlias', id, typeParameters, right };
}
export function declareVariable(id?: Schema<t.Identifier>): NodeSchema<t.DeclareVariable> {
  return { type: 'DeclareVariable', id };
}
export function declaredPredicate(value?: Schema<t.Flow>): NodeSchema<t.DeclaredPredicate> {
  return { type: 'DeclaredPredicate', value };
}
export function decorator(expression?: Schema<t.Expression>): NodeSchema<t.Decorator> {
  return { type: 'Decorator', expression };
}
export function directive(value?: Schema<t.DirectiveLiteral>): NodeSchema<t.Directive> {
  return { type: 'Directive', value };
}
export function directiveLiteral(value?: Schema<string>): NodeSchema<t.DirectiveLiteral> {
  return { type: 'DirectiveLiteral', value };
}
export function doExpression(body?: Schema<t.BlockStatement>, async?: Schema<boolean>): NodeSchema<t.DoExpression> {
  return { type: 'DoExpression', body, async };
}
export function doWhileStatement(test?: Schema<t.Expression>, body?: Schema<t.Statement>): NodeSchema<t.DoWhileStatement> {
  return { type: 'DoWhileStatement', test, body };
}
export function emptyStatement(): NodeSchema<t.EmptyStatement> {
  return { type: 'EmptyStatement',  };
}
export function emptyTypeAnnotation(): NodeSchema<t.EmptyTypeAnnotation> {
  return { type: 'EmptyTypeAnnotation',  };
}
export function enumBooleanBody(members?: Schema<Array<t.EnumBooleanMember>>): NodeSchema<t.EnumBooleanBody> {
  return { type: 'EnumBooleanBody', members };
}
export function enumBooleanMember(id?: Schema<t.Identifier>): NodeSchema<t.EnumBooleanMember> {
  return { type: 'EnumBooleanMember', id };
}
export function enumDeclaration(id?: Schema<t.Identifier>, body?: Schema<t.EnumBooleanBody | t.EnumNumberBody | t.EnumStringBody | t.EnumSymbolBody>): NodeSchema<t.EnumDeclaration> {
  return { type: 'EnumDeclaration', id, body };
}
export function enumDefaultedMember(id?: Schema<t.Identifier>): NodeSchema<t.EnumDefaultedMember> {
  return { type: 'EnumDefaultedMember', id };
}
export function enumNumberBody(members?: Schema<Array<t.EnumNumberMember>>): NodeSchema<t.EnumNumberBody> {
  return { type: 'EnumNumberBody', members };
}
export function enumNumberMember(id?: Schema<t.Identifier>, init?: Schema<t.NumericLiteral>): NodeSchema<t.EnumNumberMember> {
  return { type: 'EnumNumberMember', id, init };
}
export function enumStringBody(members?: Schema<Array<t.EnumStringMember | t.EnumDefaultedMember>>): NodeSchema<t.EnumStringBody> {
  return { type: 'EnumStringBody', members };
}
export function enumStringMember(id?: Schema<t.Identifier>, init?: Schema<t.StringLiteral>): NodeSchema<t.EnumStringMember> {
  return { type: 'EnumStringMember', id, init };
}
export function enumSymbolBody(members?: Schema<Array<t.EnumDefaultedMember>>): NodeSchema<t.EnumSymbolBody> {
  return { type: 'EnumSymbolBody', members };
}
export function existsTypeAnnotation(): NodeSchema<t.ExistsTypeAnnotation> {
  return { type: 'ExistsTypeAnnotation',  };
}
export function exportAllDeclaration(source?: Schema<t.StringLiteral>): NodeSchema<t.ExportAllDeclaration> {
  return { type: 'ExportAllDeclaration', source };
}
export function exportDefaultDeclaration(declaration?: Schema<t.TSDeclareFunction | t.FunctionDeclaration | t.ClassDeclaration | t.Expression>): NodeSchema<t.ExportDefaultDeclaration> {
  return { type: 'ExportDefaultDeclaration', declaration };
}
export function exportDefaultSpecifier(exported?: Schema<t.Identifier>): NodeSchema<t.ExportDefaultSpecifier> {
  return { type: 'ExportDefaultSpecifier', exported };
}
export function exportNamedDeclaration(declaration?: Schema<t.Declaration | null>, specifiers?: Schema<Array<t.ExportSpecifier | t.ExportDefaultSpecifier | t.ExportNamespaceSpecifier>>, source?: Schema<t.StringLiteral | null>): NodeSchema<t.ExportNamedDeclaration> {
  return { type: 'ExportNamedDeclaration', declaration, specifiers, source };
}
export function exportNamespaceSpecifier(exported?: Schema<t.Identifier>): NodeSchema<t.ExportNamespaceSpecifier> {
  return { type: 'ExportNamespaceSpecifier', exported };
}
export function exportSpecifier(local?: Schema<t.Identifier>, exported?: Schema<t.Identifier | t.StringLiteral>): NodeSchema<t.ExportSpecifier> {
  return { type: 'ExportSpecifier', local, exported };
}
export function expressionStatement(expression?: Schema<t.Expression>): NodeSchema<t.ExpressionStatement> {
  return { type: 'ExpressionStatement', expression };
}
export function file(program?: Schema<t.Program>, comments?: Schema<Array<t.CommentBlock | t.CommentLine> | null>, tokens?: Schema<Array<any> | null>): NodeSchema<t.File> {
  return { type: 'File', program, comments, tokens };
}
export function forInStatement(left?: Schema<t.VariableDeclaration | t.LVal>, right?: Schema<t.Expression>, body?: Schema<t.Statement>): NodeSchema<t.ForInStatement> {
  return { type: 'ForInStatement', left, right, body };
}
export function forOfStatement(left?: Schema<t.VariableDeclaration | t.LVal>, right?: Schema<t.Expression>, body?: Schema<t.Statement>, _await?: Schema<boolean>): NodeSchema<t.ForOfStatement> {
  return { type: 'ForOfStatement', left, right, body, await: _await };
}
export function forStatement(init?: Schema<t.VariableDeclaration | t.Expression | null>, test?: Schema<t.Expression | null>, update?: Schema<t.Expression | null>, body?: Schema<t.Statement>): NodeSchema<t.ForStatement> {
  return { type: 'ForStatement', init, test, update, body };
}
export function functionDeclaration(id?: Schema<t.Identifier | null>, params?: Schema<Array<t.Identifier | t.Pattern | t.RestElement>>, body?: Schema<t.BlockStatement>, generator?: Schema<boolean>, async?: Schema<boolean>): NodeSchema<t.FunctionDeclaration> {
  return { type: 'FunctionDeclaration', id, params, body, generator, async };
}
export function functionExpression(id?: Schema<t.Identifier | null>, params?: Schema<Array<t.Identifier | t.Pattern | t.RestElement>>, body?: Schema<t.BlockStatement>, generator?: Schema<boolean>, async?: Schema<boolean>): NodeSchema<t.FunctionExpression> {
  return { type: 'FunctionExpression', id, params, body, generator, async };
}
export function functionTypeAnnotation(typeParameters?: Schema<t.TypeParameterDeclaration | null>, params?: Schema<Array<t.FunctionTypeParam>>, rest?: Schema<t.FunctionTypeParam | null>, returnType?: Schema<t.FlowType>): NodeSchema<t.FunctionTypeAnnotation> {
  return { type: 'FunctionTypeAnnotation', typeParameters, params, rest, returnType };
}
export function functionTypeParam(name?: Schema<t.Identifier | null>, typeAnnotation?: Schema<t.FlowType>): NodeSchema<t.FunctionTypeParam> {
  return { type: 'FunctionTypeParam', name, typeAnnotation };
}
export function genericTypeAnnotation(id?: Schema<t.Identifier | t.QualifiedTypeIdentifier>, typeParameters?: Schema<t.TypeParameterInstantiation | null>): NodeSchema<t.GenericTypeAnnotation> {
  return { type: 'GenericTypeAnnotation', id, typeParameters };
}
export function identifier(name?: Schema<string>): NodeSchema<t.Identifier> {
  return { type: 'Identifier', name };
}
export function ifStatement(test?: Schema<t.Expression>, consequent?: Schema<t.Statement>, alternate?: Schema<t.Statement | null>): NodeSchema<t.IfStatement> {
  return { type: 'IfStatement', test, consequent, alternate };
}
export { _import as import };
function _import(): NodeSchema<t.Import> {
  return { type: 'Import',  };
}
export function importAttribute(key?: Schema<t.Identifier | t.StringLiteral>, value?: Schema<t.StringLiteral>): NodeSchema<t.ImportAttribute> {
  return { type: 'ImportAttribute', key, value };
}
export function importDeclaration(specifiers?: Schema<Array<t.ImportSpecifier | t.ImportDefaultSpecifier | t.ImportNamespaceSpecifier>>, source?: Schema<t.StringLiteral>): NodeSchema<t.ImportDeclaration> {
  return { type: 'ImportDeclaration', specifiers, source };
}
export function importDefaultSpecifier(local?: Schema<t.Identifier>): NodeSchema<t.ImportDefaultSpecifier> {
  return { type: 'ImportDefaultSpecifier', local };
}
export function importExpression(source?: Schema<t.Expression>, options?: Schema<t.Expression | null>): NodeSchema<t.ImportExpression> {
  return { type: 'ImportExpression', source, options };
}
export function importNamespaceSpecifier(local?: Schema<t.Identifier>): NodeSchema<t.ImportNamespaceSpecifier> {
  return { type: 'ImportNamespaceSpecifier', local };
}
export function importSpecifier(local?: Schema<t.Identifier>, imported?: Schema<t.Identifier | t.StringLiteral>): NodeSchema<t.ImportSpecifier> {
  return { type: 'ImportSpecifier', local, imported };
}
export function indexedAccessType(objectType?: Schema<t.FlowType>, indexType?: Schema<t.FlowType>): NodeSchema<t.IndexedAccessType> {
  return { type: 'IndexedAccessType', objectType, indexType };
}
export function inferredPredicate(): NodeSchema<t.InferredPredicate> {
  return { type: 'InferredPredicate',  };
}
export function interfaceDeclaration(id?: Schema<t.Identifier>, typeParameters?: Schema<t.TypeParameterDeclaration | null>, _extends?: Schema<Array<t.InterfaceExtends> | null>, body?: Schema<t.ObjectTypeAnnotation>): NodeSchema<t.InterfaceDeclaration> {
  return { type: 'InterfaceDeclaration', id, typeParameters, extends: _extends, body };
}
export function interfaceExtends(id?: Schema<t.Identifier | t.QualifiedTypeIdentifier>, typeParameters?: Schema<t.TypeParameterInstantiation | null>): NodeSchema<t.InterfaceExtends> {
  return { type: 'InterfaceExtends', id, typeParameters };
}
export function interfaceTypeAnnotation(_extends?: Schema<Array<t.InterfaceExtends> | null>, body?: Schema<t.ObjectTypeAnnotation>): NodeSchema<t.InterfaceTypeAnnotation> {
  return { type: 'InterfaceTypeAnnotation', extends: _extends, body };
}
export function interpreterDirective(value?: Schema<string>): NodeSchema<t.InterpreterDirective> {
  return { type: 'InterpreterDirective', value };
}
export function intersectionTypeAnnotation(types?: Schema<Array<t.FlowType>>): NodeSchema<t.IntersectionTypeAnnotation> {
  return { type: 'IntersectionTypeAnnotation', types };
}
export function jsxAttribute(name?: Schema<t.JSXIdentifier | t.JSXNamespacedName>, value?: Schema<t.JSXElement | t.JSXFragment | t.StringLiteral | t.JSXExpressionContainer | null>): NodeSchema<t.JSXAttribute> {
  return { type: 'JSXAttribute', name, value };
}
export function jsxClosingElement(name?: Schema<t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName>): NodeSchema<t.JSXClosingElement> {
  return { type: 'JSXClosingElement', name };
}
export function jsxClosingFragment(): NodeSchema<t.JSXClosingFragment> {
  return { type: 'JSXClosingFragment',  };
}
export function jsxElement(openingElement?: Schema<t.JSXOpeningElement>, closingElement?: Schema<t.JSXClosingElement | null>, children?: Schema<Array<t.JSXText | t.JSXExpressionContainer | t.JSXSpreadChild | t.JSXElement | t.JSXFragment>>, selfClosing?: Schema<boolean | null>): NodeSchema<t.JSXElement> {
  return { type: 'JSXElement', openingElement, closingElement, children, selfClosing };
}
export function jsxEmptyExpression(): NodeSchema<t.JSXEmptyExpression> {
  return { type: 'JSXEmptyExpression',  };
}
export function jsxExpressionContainer(expression?: Schema<t.Expression | t.JSXEmptyExpression>): NodeSchema<t.JSXExpressionContainer> {
  return { type: 'JSXExpressionContainer', expression };
}
export function jsxFragment(openingFragment?: Schema<t.JSXOpeningFragment>, closingFragment?: Schema<t.JSXClosingFragment>, children?: Schema<Array<t.JSXText | t.JSXExpressionContainer | t.JSXSpreadChild | t.JSXElement | t.JSXFragment>>): NodeSchema<t.JSXFragment> {
  return { type: 'JSXFragment', openingFragment, closingFragment, children };
}
export function jsxIdentifier(name?: Schema<string>): NodeSchema<t.JSXIdentifier> {
  return { type: 'JSXIdentifier', name };
}
export function jsxMemberExpression(object?: Schema<t.JSXMemberExpression | t.JSXIdentifier>, property?: Schema<t.JSXIdentifier>): NodeSchema<t.JSXMemberExpression> {
  return { type: 'JSXMemberExpression', object, property };
}
export function jsxNamespacedName(namespace?: Schema<t.JSXIdentifier>, name?: Schema<t.JSXIdentifier>): NodeSchema<t.JSXNamespacedName> {
  return { type: 'JSXNamespacedName', namespace, name };
}
export function jsxOpeningElement(name?: Schema<t.JSXIdentifier | t.JSXMemberExpression | t.JSXNamespacedName>, attributes?: Schema<Array<t.JSXAttribute | t.JSXSpreadAttribute>>, selfClosing?: Schema<boolean>): NodeSchema<t.JSXOpeningElement> {
  return { type: 'JSXOpeningElement', name, attributes, selfClosing };
}
export function jsxOpeningFragment(): NodeSchema<t.JSXOpeningFragment> {
  return { type: 'JSXOpeningFragment',  };
}
export function jsxSpreadAttribute(argument?: Schema<t.Expression>): NodeSchema<t.JSXSpreadAttribute> {
  return { type: 'JSXSpreadAttribute', argument };
}
export function jsxSpreadChild(expression?: Schema<t.Expression>): NodeSchema<t.JSXSpreadChild> {
  return { type: 'JSXSpreadChild', expression };
}
export function jsxText(value?: Schema<string>): NodeSchema<t.JSXText> {
  return { type: 'JSXText', value };
}
export function labeledStatement(label?: Schema<t.Identifier>, body?: Schema<t.Statement>): NodeSchema<t.LabeledStatement> {
  return { type: 'LabeledStatement', label, body };
}
export function logicalExpression(operator?: Schema<"||" | "&&" | "??">, left?: Schema<t.Expression>, right?: Schema<t.Expression>): NodeSchema<t.LogicalExpression> {
  return { type: 'LogicalExpression', operator, left, right };
}
export function memberExpression(object?: Schema<t.Expression | t.Super>, property?: Schema<t.Expression | t.Identifier | t.PrivateName>, computed?: Schema<boolean>, optional?: Schema<boolean | null>): NodeSchema<t.MemberExpression> {
  return { type: 'MemberExpression', object, property, computed, optional };
}
export function metaProperty(meta?: Schema<t.Identifier>, property?: Schema<t.Identifier>): NodeSchema<t.MetaProperty> {
  return { type: 'MetaProperty', meta, property };
}
export function mixedTypeAnnotation(): NodeSchema<t.MixedTypeAnnotation> {
  return { type: 'MixedTypeAnnotation',  };
}
export function moduleExpression(body?: Schema<t.Program>): NodeSchema<t.ModuleExpression> {
  return { type: 'ModuleExpression', body };
}
export function newExpression(callee?: Schema<t.Expression | t.Super | t.V8IntrinsicIdentifier>, _arguments?: Schema<Array<t.Expression | t.SpreadElement | t.ArgumentPlaceholder>>): NodeSchema<t.NewExpression> {
  return { type: 'NewExpression', callee, arguments: _arguments };
}
export function noop(): NodeSchema<t.Noop> {
  return { type: 'Noop',  };
}
export function nullLiteral(): NodeSchema<t.NullLiteral> {
  return { type: 'NullLiteral',  };
}
export function nullLiteralTypeAnnotation(): NodeSchema<t.NullLiteralTypeAnnotation> {
  return { type: 'NullLiteralTypeAnnotation',  };
}
export function nullableTypeAnnotation(typeAnnotation?: Schema<t.FlowType>): NodeSchema<t.NullableTypeAnnotation> {
  return { type: 'NullableTypeAnnotation', typeAnnotation };
}
export function numberLiteralTypeAnnotation(value?: Schema<number>): NodeSchema<t.NumberLiteralTypeAnnotation> {
  return { type: 'NumberLiteralTypeAnnotation', value };
}
export function numberTypeAnnotation(): NodeSchema<t.NumberTypeAnnotation> {
  return { type: 'NumberTypeAnnotation',  };
}
export function numericLiteral(value?: Schema<number>): NodeSchema<t.NumericLiteral> {
  return { type: 'NumericLiteral', value };
}
export function objectExpression(properties?: Schema<Array<t.ObjectMethod | t.ObjectProperty | t.SpreadElement>>): NodeSchema<t.ObjectExpression> {
  return { type: 'ObjectExpression', properties };
}
export function objectMethod(kind?: Schema<"method" | "get" | "set">, key?: Schema<t.Expression | t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral>, params?: Schema<Array<t.Identifier | t.Pattern | t.RestElement>>, body?: Schema<t.BlockStatement>, computed?: Schema<boolean>, generator?: Schema<boolean>, async?: Schema<boolean>): NodeSchema<t.ObjectMethod> {
  return { type: 'ObjectMethod', kind, key, params, body, computed, generator, async };
}
export function objectPattern(properties?: Schema<Array<t.RestElement | t.ObjectProperty>>): NodeSchema<t.ObjectPattern> {
  return { type: 'ObjectPattern', properties };
}
export function objectProperty(key?: Schema<t.Expression | t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral | t.DecimalLiteral | t.PrivateName>, value?: Schema<t.Expression | t.PatternLike>, computed?: Schema<boolean>, shorthand?: Schema<boolean>, decorators?: Schema<Array<t.Decorator> | null>): NodeSchema<t.ObjectProperty> {
  return { type: 'ObjectProperty', key, value, computed, shorthand, decorators };
}
export function objectTypeAnnotation(properties?: Schema<Array<t.ObjectTypeProperty | t.ObjectTypeSpreadProperty>>, indexers?: Schema<Array<t.ObjectTypeIndexer>>, callProperties?: Schema<Array<t.ObjectTypeCallProperty>>, internalSlots?: Schema<Array<t.ObjectTypeInternalSlot>>, exact?: Schema<boolean>): NodeSchema<t.ObjectTypeAnnotation> {
  return { type: 'ObjectTypeAnnotation', properties, indexers, callProperties, internalSlots, exact };
}
export function objectTypeCallProperty(value?: Schema<t.FlowType>): NodeSchema<t.ObjectTypeCallProperty> {
  return { type: 'ObjectTypeCallProperty', value };
}
export function objectTypeIndexer(id?: Schema<t.Identifier | null>, key?: Schema<t.FlowType>, value?: Schema<t.FlowType>, variance?: Schema<t.Variance | null>): NodeSchema<t.ObjectTypeIndexer> {
  return { type: 'ObjectTypeIndexer', id, key, value, variance };
}
export function objectTypeInternalSlot(id?: Schema<t.Identifier>, value?: Schema<t.FlowType>, optional?: Schema<boolean>, _static?: Schema<boolean>, method?: Schema<boolean>): NodeSchema<t.ObjectTypeInternalSlot> {
  return { type: 'ObjectTypeInternalSlot', id, value, optional, static: _static, method };
}
export function objectTypeProperty(key?: Schema<t.Identifier | t.StringLiteral>, value?: Schema<t.FlowType>, variance?: Schema<t.Variance | null>): NodeSchema<t.ObjectTypeProperty> {
  return { type: 'ObjectTypeProperty', key, value, variance };
}
export function objectTypeSpreadProperty(argument?: Schema<t.FlowType>): NodeSchema<t.ObjectTypeSpreadProperty> {
  return { type: 'ObjectTypeSpreadProperty', argument };
}
export function opaqueType(id?: Schema<t.Identifier>, typeParameters?: Schema<t.TypeParameterDeclaration | null>, supertype?: Schema<t.FlowType | null>, impltype?: Schema<t.FlowType>): NodeSchema<t.OpaqueType> {
  return { type: 'OpaqueType', id, typeParameters, supertype, impltype };
}
export function optionalCallExpression(callee?: Schema<t.Expression>, _arguments?: Schema<Array<t.Expression | t.SpreadElement | t.ArgumentPlaceholder>>, optional?: Schema<boolean>): NodeSchema<t.OptionalCallExpression> {
  return { type: 'OptionalCallExpression', callee, arguments: _arguments, optional };
}
export function optionalIndexedAccessType(objectType?: Schema<t.FlowType>, indexType?: Schema<t.FlowType>): NodeSchema<t.OptionalIndexedAccessType> {
  return { type: 'OptionalIndexedAccessType', objectType, indexType };
}
export function optionalMemberExpression(object?: Schema<t.Expression>, property?: Schema<t.Expression | t.Identifier>, computed?: Schema<boolean>, optional?: Schema<boolean>): NodeSchema<t.OptionalMemberExpression> {
  return { type: 'OptionalMemberExpression', object, property, computed, optional };
}
export function parenthesizedExpression(expression?: Schema<t.Expression>): NodeSchema<t.ParenthesizedExpression> {
  return { type: 'ParenthesizedExpression', expression };
}
export function pipelineBareFunction(callee?: Schema<t.Expression>): NodeSchema<t.PipelineBareFunction> {
  return { type: 'PipelineBareFunction', callee };
}
export function pipelinePrimaryTopicReference(): NodeSchema<t.PipelinePrimaryTopicReference> {
  return { type: 'PipelinePrimaryTopicReference',  };
}
export function pipelineTopicExpression(expression?: Schema<t.Expression>): NodeSchema<t.PipelineTopicExpression> {
  return { type: 'PipelineTopicExpression', expression };
}
export function placeholder(expectedNode?: Schema<"Identifier" | "StringLiteral" | "Expression" | "Statement" | "Declaration" | "BlockStatement" | "ClassBody" | "Pattern">, name?: Schema<t.Identifier>): NodeSchema<t.Placeholder> {
  return { type: 'Placeholder', expectedNode, name };
}
export function privateName(id?: Schema<t.Identifier>): NodeSchema<t.PrivateName> {
  return { type: 'PrivateName', id };
}
export function program(body?: Schema<Array<t.Statement>>, directives?: Schema<Array<t.Directive>>, sourceType?: Schema<"script" | "module">, interpreter?: Schema<t.InterpreterDirective | null>): NodeSchema<t.Program> {
  return { type: 'Program', body, directives, sourceType, interpreter };
}
export function qualifiedTypeIdentifier(id?: Schema<t.Identifier>, qualification?: Schema<t.Identifier | t.QualifiedTypeIdentifier>): NodeSchema<t.QualifiedTypeIdentifier> {
  return { type: 'QualifiedTypeIdentifier', id, qualification };
}
export function recordExpression(properties?: Schema<Array<t.ObjectProperty | t.SpreadElement>>): NodeSchema<t.RecordExpression> {
  return { type: 'RecordExpression', properties };
}
export function regExpLiteral(pattern?: Schema<string>, flags?: Schema<string>): NodeSchema<t.RegExpLiteral> {
  return { type: 'RegExpLiteral', pattern, flags };
}
export function restElement(argument?: Schema<t.LVal>): NodeSchema<t.RestElement> {
  return { type: 'RestElement', argument };
}
export function returnStatement(argument?: Schema<t.Expression | null>): NodeSchema<t.ReturnStatement> {
  return { type: 'ReturnStatement', argument };
}
export function sequenceExpression(expressions?: Schema<Array<t.Expression>>): NodeSchema<t.SequenceExpression> {
  return { type: 'SequenceExpression', expressions };
}
export function spreadElement(argument?: Schema<t.Expression>): NodeSchema<t.SpreadElement> {
  return { type: 'SpreadElement', argument };
}
export function staticBlock(body?: Schema<Array<t.Statement>>): NodeSchema<t.StaticBlock> {
  return { type: 'StaticBlock', body };
}
export function stringLiteral(value?: Schema<string>): NodeSchema<t.StringLiteral> {
  return { type: 'StringLiteral', value };
}
export function stringLiteralTypeAnnotation(value?: Schema<string>): NodeSchema<t.StringLiteralTypeAnnotation> {
  return { type: 'StringLiteralTypeAnnotation', value };
}
export function stringTypeAnnotation(): NodeSchema<t.StringTypeAnnotation> {
  return { type: 'StringTypeAnnotation',  };
}
export { _super as super };
function _super(): NodeSchema<t.Super> {
  return { type: 'Super',  };
}
export function switchCase(test?: Schema<t.Expression | null>, consequent?: Schema<Array<t.Statement>>): NodeSchema<t.SwitchCase> {
  return { type: 'SwitchCase', test, consequent };
}
export function switchStatement(discriminant?: Schema<t.Expression>, cases?: Schema<Array<t.SwitchCase>>): NodeSchema<t.SwitchStatement> {
  return { type: 'SwitchStatement', discriminant, cases };
}
export function symbolTypeAnnotation(): NodeSchema<t.SymbolTypeAnnotation> {
  return { type: 'SymbolTypeAnnotation',  };
}
export function tsAnyKeyword(): NodeSchema<t.TSAnyKeyword> {
  return { type: 'TSAnyKeyword',  };
}
export function tsArrayType(elementType?: Schema<t.TSType>): NodeSchema<t.TSArrayType> {
  return { type: 'TSArrayType', elementType };
}
export function tsAsExpression(expression?: Schema<t.Expression>, typeAnnotation?: Schema<t.TSType>): NodeSchema<t.TSAsExpression> {
  return { type: 'TSAsExpression', expression, typeAnnotation };
}
export function tsBigIntKeyword(): NodeSchema<t.TSBigIntKeyword> {
  return { type: 'TSBigIntKeyword',  };
}
export function tsBooleanKeyword(): NodeSchema<t.TSBooleanKeyword> {
  return { type: 'TSBooleanKeyword',  };
}
export function tsCallSignatureDeclaration(typeParameters?: Schema<t.TSTypeParameterDeclaration | null>, parameters?: Schema<Array<t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement>>, typeAnnotation?: Schema<t.TSTypeAnnotation | null>): NodeSchema<t.TSCallSignatureDeclaration> {
  return { type: 'TSCallSignatureDeclaration', typeParameters, parameters, typeAnnotation };
}
export function tsConditionalType(checkType?: Schema<t.TSType>, extendsType?: Schema<t.TSType>, trueType?: Schema<t.TSType>, falseType?: Schema<t.TSType>): NodeSchema<t.TSConditionalType> {
  return { type: 'TSConditionalType', checkType, extendsType, trueType, falseType };
}
export function tsConstructSignatureDeclaration(typeParameters?: Schema<t.TSTypeParameterDeclaration | null>, parameters?: Schema<Array<t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement>>, typeAnnotation?: Schema<t.TSTypeAnnotation | null>): NodeSchema<t.TSConstructSignatureDeclaration> {
  return { type: 'TSConstructSignatureDeclaration', typeParameters, parameters, typeAnnotation };
}
export function tsConstructorType(typeParameters?: Schema<t.TSTypeParameterDeclaration | null>, parameters?: Schema<Array<t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement>>, typeAnnotation?: Schema<t.TSTypeAnnotation | null>): NodeSchema<t.TSConstructorType> {
  return { type: 'TSConstructorType', typeParameters, parameters, typeAnnotation };
}
export function tsDeclareFunction(id?: Schema<t.Identifier | null>, typeParameters?: Schema<t.TSTypeParameterDeclaration | t.Noop | null>, params?: Schema<Array<t.Identifier | t.Pattern | t.RestElement>>, returnType?: Schema<t.TSTypeAnnotation | t.Noop | null>): NodeSchema<t.TSDeclareFunction> {
  return { type: 'TSDeclareFunction', id, typeParameters, params, returnType };
}
export function tsDeclareMethod(decorators?: Schema<Array<t.Decorator> | null>, key?: Schema<t.Identifier | t.StringLiteral | t.NumericLiteral | t.BigIntLiteral | t.Expression>, typeParameters?: Schema<t.TSTypeParameterDeclaration | t.Noop | null>, params?: Schema<Array<t.Identifier | t.Pattern | t.RestElement | t.TSParameterProperty>>, returnType?: Schema<t.TSTypeAnnotation | t.Noop | null>): NodeSchema<t.TSDeclareMethod> {
  return { type: 'TSDeclareMethod', decorators, key, typeParameters, params, returnType };
}
export function tsEnumBody(members?: Schema<Array<t.TSEnumMember>>): NodeSchema<t.TSEnumBody> {
  return { type: 'TSEnumBody', members };
}
export function tsEnumDeclaration(id?: Schema<t.Identifier>, members?: Schema<Array<t.TSEnumMember>>): NodeSchema<t.TSEnumDeclaration> {
  return { type: 'TSEnumDeclaration', id, members };
}
export function tsEnumMember(id?: Schema<t.Identifier | t.StringLiteral>, initializer?: Schema<t.Expression | null>): NodeSchema<t.TSEnumMember> {
  return { type: 'TSEnumMember', id, initializer };
}
export function tsExportAssignment(expression?: Schema<t.Expression>): NodeSchema<t.TSExportAssignment> {
  return { type: 'TSExportAssignment', expression };
}
export function tsExpressionWithTypeArguments(expression?: Schema<t.TSEntityName>, typeParameters?: Schema<t.TSTypeParameterInstantiation | null>): NodeSchema<t.TSExpressionWithTypeArguments> {
  return { type: 'TSExpressionWithTypeArguments', expression, typeParameters };
}
export function tsExternalModuleReference(expression?: Schema<t.StringLiteral>): NodeSchema<t.TSExternalModuleReference> {
  return { type: 'TSExternalModuleReference', expression };
}
export function tsFunctionType(typeParameters?: Schema<t.TSTypeParameterDeclaration | null>, parameters?: Schema<Array<t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement>>, typeAnnotation?: Schema<t.TSTypeAnnotation | null>): NodeSchema<t.TSFunctionType> {
  return { type: 'TSFunctionType', typeParameters, parameters, typeAnnotation };
}
export function tsImportEqualsDeclaration(id?: Schema<t.Identifier>, moduleReference?: Schema<t.TSEntityName | t.TSExternalModuleReference>): NodeSchema<t.TSImportEqualsDeclaration> {
  return { type: 'TSImportEqualsDeclaration', id, moduleReference };
}
export function tsImportType(argument?: Schema<t.StringLiteral>, qualifier?: Schema<t.TSEntityName | null>, typeParameters?: Schema<t.TSTypeParameterInstantiation | null>): NodeSchema<t.TSImportType> {
  return { type: 'TSImportType', argument, qualifier, typeParameters };
}
export function tsIndexSignature(parameters?: Schema<Array<t.Identifier>>, typeAnnotation?: Schema<t.TSTypeAnnotation | null>): NodeSchema<t.TSIndexSignature> {
  return { type: 'TSIndexSignature', parameters, typeAnnotation };
}
export function tsIndexedAccessType(objectType?: Schema<t.TSType>, indexType?: Schema<t.TSType>): NodeSchema<t.TSIndexedAccessType> {
  return { type: 'TSIndexedAccessType', objectType, indexType };
}
export function tsInferType(typeParameter?: Schema<t.TSTypeParameter>): NodeSchema<t.TSInferType> {
  return { type: 'TSInferType', typeParameter };
}
export function tsInstantiationExpression(expression?: Schema<t.Expression>, typeParameters?: Schema<t.TSTypeParameterInstantiation | null>): NodeSchema<t.TSInstantiationExpression> {
  return { type: 'TSInstantiationExpression', expression, typeParameters };
}
export function tsInterfaceBody(body?: Schema<Array<t.TSTypeElement>>): NodeSchema<t.TSInterfaceBody> {
  return { type: 'TSInterfaceBody', body };
}
export function tsInterfaceDeclaration(id?: Schema<t.Identifier>, typeParameters?: Schema<t.TSTypeParameterDeclaration | null>, _extends?: Schema<Array<t.TSExpressionWithTypeArguments> | null>, body?: Schema<t.TSInterfaceBody>): NodeSchema<t.TSInterfaceDeclaration> {
  return { type: 'TSInterfaceDeclaration', id, typeParameters, extends: _extends, body };
}
export function tsIntersectionType(types?: Schema<Array<t.TSType>>): NodeSchema<t.TSIntersectionType> {
  return { type: 'TSIntersectionType', types };
}
export function tsIntrinsicKeyword(): NodeSchema<t.TSIntrinsicKeyword> {
  return { type: 'TSIntrinsicKeyword',  };
}
export function tsLiteralType(literal?: Schema<t.NumericLiteral | t.StringLiteral | t.BooleanLiteral | t.BigIntLiteral | t.TemplateLiteral | t.UnaryExpression>): NodeSchema<t.TSLiteralType> {
  return { type: 'TSLiteralType', literal };
}
export function tsMappedType(typeParameter?: Schema<t.TSTypeParameter>, typeAnnotation?: Schema<t.TSType | null>, nameType?: Schema<t.TSType | null>): NodeSchema<t.TSMappedType> {
  return { type: 'TSMappedType', typeParameter, typeAnnotation, nameType };
}
export function tsMethodSignature(key?: Schema<t.Expression>, typeParameters?: Schema<t.TSTypeParameterDeclaration | null>, parameters?: Schema<Array<t.ArrayPattern | t.Identifier | t.ObjectPattern | t.RestElement>>, typeAnnotation?: Schema<t.TSTypeAnnotation | null>): NodeSchema<t.TSMethodSignature> {
  return { type: 'TSMethodSignature', key, typeParameters, parameters, typeAnnotation };
}
export function tsModuleBlock(body?: Schema<Array<t.Statement>>): NodeSchema<t.TSModuleBlock> {
  return { type: 'TSModuleBlock', body };
}
export function tsModuleDeclaration(id?: Schema<t.Identifier | t.StringLiteral>, body?: Schema<t.TSModuleBlock | t.TSModuleDeclaration>): NodeSchema<t.TSModuleDeclaration> {
  return { type: 'TSModuleDeclaration', id, body };
}
export function tsNamedTupleMember(label?: Schema<t.Identifier>, elementType?: Schema<t.TSType>, optional?: Schema<boolean>): NodeSchema<t.TSNamedTupleMember> {
  return { type: 'TSNamedTupleMember', label, elementType, optional };
}
export function tsNamespaceExportDeclaration(id?: Schema<t.Identifier>): NodeSchema<t.TSNamespaceExportDeclaration> {
  return { type: 'TSNamespaceExportDeclaration', id };
}
export function tsNeverKeyword(): NodeSchema<t.TSNeverKeyword> {
  return { type: 'TSNeverKeyword',  };
}
export function tsNonNullExpression(expression?: Schema<t.Expression>): NodeSchema<t.TSNonNullExpression> {
  return { type: 'TSNonNullExpression', expression };
}
export function tsNullKeyword(): NodeSchema<t.TSNullKeyword> {
  return { type: 'TSNullKeyword',  };
}
export function tsNumberKeyword(): NodeSchema<t.TSNumberKeyword> {
  return { type: 'TSNumberKeyword',  };
}
export function tsObjectKeyword(): NodeSchema<t.TSObjectKeyword> {
  return { type: 'TSObjectKeyword',  };
}
export function tsOptionalType(typeAnnotation?: Schema<t.TSType>): NodeSchema<t.TSOptionalType> {
  return { type: 'TSOptionalType', typeAnnotation };
}
export function tsParameterProperty(parameter?: Schema<t.Identifier | t.AssignmentPattern>): NodeSchema<t.TSParameterProperty> {
  return { type: 'TSParameterProperty', parameter };
}
export function tsParenthesizedType(typeAnnotation?: Schema<t.TSType>): NodeSchema<t.TSParenthesizedType> {
  return { type: 'TSParenthesizedType', typeAnnotation };
}
export function tsPropertySignature(key?: Schema<t.Expression>, typeAnnotation?: Schema<t.TSTypeAnnotation | null>): NodeSchema<t.TSPropertySignature> {
  return { type: 'TSPropertySignature', key, typeAnnotation };
}
export function tsQualifiedName(left?: Schema<t.TSEntityName>, right?: Schema<t.Identifier>): NodeSchema<t.TSQualifiedName> {
  return { type: 'TSQualifiedName', left, right };
}
export function tsRestType(typeAnnotation?: Schema<t.TSType>): NodeSchema<t.TSRestType> {
  return { type: 'TSRestType', typeAnnotation };
}
export function tsSatisfiesExpression(expression?: Schema<t.Expression>, typeAnnotation?: Schema<t.TSType>): NodeSchema<t.TSSatisfiesExpression> {
  return { type: 'TSSatisfiesExpression', expression, typeAnnotation };
}
export function tsStringKeyword(): NodeSchema<t.TSStringKeyword> {
  return { type: 'TSStringKeyword',  };
}
export function tsSymbolKeyword(): NodeSchema<t.TSSymbolKeyword> {
  return { type: 'TSSymbolKeyword',  };
}
export function tsTemplateLiteralType(quasis?: Schema<Array<t.TemplateElement>>, types?: Schema<Array<t.TSType>>): NodeSchema<t.TSTemplateLiteralType> {
  return { type: 'TSTemplateLiteralType', quasis, types };
}
export function tsThisType(): NodeSchema<t.TSThisType> {
  return { type: 'TSThisType',  };
}
export function tsTupleType(elementTypes?: Schema<Array<t.TSType | t.TSNamedTupleMember>>): NodeSchema<t.TSTupleType> {
  return { type: 'TSTupleType', elementTypes };
}
export function tsTypeAliasDeclaration(id?: Schema<t.Identifier>, typeParameters?: Schema<t.TSTypeParameterDeclaration | null>, typeAnnotation?: Schema<t.TSType>): NodeSchema<t.TSTypeAliasDeclaration> {
  return { type: 'TSTypeAliasDeclaration', id, typeParameters, typeAnnotation };
}
export function tsTypeAnnotation(typeAnnotation?: Schema<t.TSType>): NodeSchema<t.TSTypeAnnotation> {
  return { type: 'TSTypeAnnotation', typeAnnotation };
}
export function tsTypeAssertion(typeAnnotation?: Schema<t.TSType>, expression?: Schema<t.Expression>): NodeSchema<t.TSTypeAssertion> {
  return { type: 'TSTypeAssertion', typeAnnotation, expression };
}
export function tsTypeLiteral(members?: Schema<Array<t.TSTypeElement>>): NodeSchema<t.TSTypeLiteral> {
  return { type: 'TSTypeLiteral', members };
}
export function tsTypeOperator(typeAnnotation?: Schema<t.TSType>): NodeSchema<t.TSTypeOperator> {
  return { type: 'TSTypeOperator', typeAnnotation };
}
export function tsTypeParameter(constraint?: Schema<t.TSType | null>, _default?: Schema<t.TSType | null>, name?: Schema<string>): NodeSchema<t.TSTypeParameter> {
  return { type: 'TSTypeParameter', constraint, default: _default, name };
}
export function tsTypeParameterDeclaration(params?: Schema<Array<t.TSTypeParameter>>): NodeSchema<t.TSTypeParameterDeclaration> {
  return { type: 'TSTypeParameterDeclaration', params };
}
export function tsTypeParameterInstantiation(params?: Schema<Array<t.TSType>>): NodeSchema<t.TSTypeParameterInstantiation> {
  return { type: 'TSTypeParameterInstantiation', params };
}
export function tsTypePredicate(parameterName?: Schema<t.Identifier | t.TSThisType>, typeAnnotation?: Schema<t.TSTypeAnnotation | null>, asserts?: Schema<boolean | null>): NodeSchema<t.TSTypePredicate> {
  return { type: 'TSTypePredicate', parameterName, typeAnnotation, asserts };
}
export function tsTypeQuery(exprName?: Schema<t.TSEntityName | t.TSImportType>, typeParameters?: Schema<t.TSTypeParameterInstantiation | null>): NodeSchema<t.TSTypeQuery> {
  return { type: 'TSTypeQuery', exprName, typeParameters };
}
export function tsTypeReference(typeName?: Schema<t.TSEntityName>, typeParameters?: Schema<t.TSTypeParameterInstantiation | null>): NodeSchema<t.TSTypeReference> {
  return { type: 'TSTypeReference', typeName, typeParameters };
}
export function tsUndefinedKeyword(): NodeSchema<t.TSUndefinedKeyword> {
  return { type: 'TSUndefinedKeyword',  };
}
export function tsUnionType(types?: Schema<Array<t.TSType>>): NodeSchema<t.TSUnionType> {
  return { type: 'TSUnionType', types };
}
export function tsUnknownKeyword(): NodeSchema<t.TSUnknownKeyword> {
  return { type: 'TSUnknownKeyword',  };
}
export function tsVoidKeyword(): NodeSchema<t.TSVoidKeyword> {
  return { type: 'TSVoidKeyword',  };
}
export function taggedTemplateExpression(tag?: Schema<t.Expression>, quasi?: Schema<t.TemplateLiteral>): NodeSchema<t.TaggedTemplateExpression> {
  return { type: 'TaggedTemplateExpression', tag, quasi };
}
export function templateElement(value?: Schema<any>, tail?: Schema<boolean>): NodeSchema<t.TemplateElement> {
  return { type: 'TemplateElement', value, tail };
}
export function templateLiteral(quasis?: Schema<Array<t.TemplateElement>>, expressions?: Schema<Array<t.Expression | t.TSType>>): NodeSchema<t.TemplateLiteral> {
  return { type: 'TemplateLiteral', quasis, expressions };
}
export function thisExpression(): NodeSchema<t.ThisExpression> {
  return { type: 'ThisExpression',  };
}
export function thisTypeAnnotation(): NodeSchema<t.ThisTypeAnnotation> {
  return { type: 'ThisTypeAnnotation',  };
}
export function throwStatement(argument?: Schema<t.Expression>): NodeSchema<t.ThrowStatement> {
  return { type: 'ThrowStatement', argument };
}
export function topicReference(): NodeSchema<t.TopicReference> {
  return { type: 'TopicReference',  };
}
export function tryStatement(block?: Schema<t.BlockStatement>, handler?: Schema<t.CatchClause | null>, finalizer?: Schema<t.BlockStatement | null>): NodeSchema<t.TryStatement> {
  return { type: 'TryStatement', block, handler, finalizer };
}
export function tupleExpression(elements?: Schema<Array<t.Expression | t.SpreadElement>>): NodeSchema<t.TupleExpression> {
  return { type: 'TupleExpression', elements };
}
export function tupleTypeAnnotation(types?: Schema<Array<t.FlowType>>): NodeSchema<t.TupleTypeAnnotation> {
  return { type: 'TupleTypeAnnotation', types };
}
export function typeAlias(id?: Schema<t.Identifier>, typeParameters?: Schema<t.TypeParameterDeclaration | null>, right?: Schema<t.FlowType>): NodeSchema<t.TypeAlias> {
  return { type: 'TypeAlias', id, typeParameters, right };
}
export function typeAnnotation(typeAnnotation?: Schema<t.FlowType>): NodeSchema<t.TypeAnnotation> {
  return { type: 'TypeAnnotation', typeAnnotation };
}
export function typeCastExpression(expression?: Schema<t.Expression>, typeAnnotation?: Schema<t.TypeAnnotation>): NodeSchema<t.TypeCastExpression> {
  return { type: 'TypeCastExpression', expression, typeAnnotation };
}
export function typeParameter(bound?: Schema<t.TypeAnnotation | null>, _default?: Schema<t.FlowType | null>, variance?: Schema<t.Variance | null>): NodeSchema<t.TypeParameter> {
  return { type: 'TypeParameter', bound, default: _default, variance };
}
export function typeParameterDeclaration(params?: Schema<Array<t.TypeParameter>>): NodeSchema<t.TypeParameterDeclaration> {
  return { type: 'TypeParameterDeclaration', params };
}
export function typeParameterInstantiation(params?: Schema<Array<t.FlowType>>): NodeSchema<t.TypeParameterInstantiation> {
  return { type: 'TypeParameterInstantiation', params };
}
export function typeofTypeAnnotation(argument?: Schema<t.FlowType>): NodeSchema<t.TypeofTypeAnnotation> {
  return { type: 'TypeofTypeAnnotation', argument };
}
export function unaryExpression(operator?: Schema<"void" | "throw" | "delete" | "!" | "+" | "-" | "~" | "typeof">, argument?: Schema<t.Expression>, prefix?: Schema<boolean>): NodeSchema<t.UnaryExpression> {
  return { type: 'UnaryExpression', operator, argument, prefix };
}
export function unionTypeAnnotation(types?: Schema<Array<t.FlowType>>): NodeSchema<t.UnionTypeAnnotation> {
  return { type: 'UnionTypeAnnotation', types };
}
export function updateExpression(operator?: Schema<"++" | "--">, argument?: Schema<t.Expression>, prefix?: Schema<boolean>): NodeSchema<t.UpdateExpression> {
  return { type: 'UpdateExpression', operator, argument, prefix };
}
export function v8IntrinsicIdentifier(name?: Schema<string>): NodeSchema<t.V8IntrinsicIdentifier> {
  return { type: 'V8IntrinsicIdentifier', name };
}
export function variableDeclaration(kind?: Schema<"var" | "let" | "const" | "using" | "await using">, declarations?: Schema<Array<t.VariableDeclarator>>): NodeSchema<t.VariableDeclaration> {
  return { type: 'VariableDeclaration', kind, declarations };
}
export function variableDeclarator(id?: Schema<t.LVal>, init?: Schema<t.Expression | null>): NodeSchema<t.VariableDeclarator> {
  return { type: 'VariableDeclarator', id, init };
}
export function variance(kind?: Schema<"minus" | "plus">): NodeSchema<t.Variance> {
  return { type: 'Variance', kind };
}
export function voidTypeAnnotation(): NodeSchema<t.VoidTypeAnnotation> {
  return { type: 'VoidTypeAnnotation',  };
}
export function whileStatement(test?: Schema<t.Expression>, body?: Schema<t.Statement>): NodeSchema<t.WhileStatement> {
  return { type: 'WhileStatement', test, body };
}
export function withStatement(object?: Schema<t.Expression>, body?: Schema<t.Statement>): NodeSchema<t.WithStatement> {
  return { type: 'WithStatement', object, body };
}
export function yieldExpression(argument?: Schema<t.Expression | null>, delegate?: Schema<boolean>): NodeSchema<t.YieldExpression> {
  return { type: 'YieldExpression', argument, delegate };
}
