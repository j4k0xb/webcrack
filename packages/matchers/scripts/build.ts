import * as t from '@babel/types';
import { createWriteStream } from 'node:fs';

type Validator = Required<t.FieldOptions>['validate'];

const out = createWriteStream(new URL('../src/generated.ts', import.meta.url));

out.write(`// This file is generated by scripts/build.ts. Do not edit manually.
import type * as t from '@babel/types';
import type { NodeSchema, Schema } from './types.js';

`);

for (const type of Object.keys(t.BUILDER_KEYS).sort()) {
  const exportedName = toFunctionName(type);
  const functionName = t.toBindingIdentifierName(exportedName);

  if (exportedName === functionName) {
    out.write(`export `);
  } else {
    out.write(`export { ${functionName} as ${exportedName} };\n`);
  }

  out.write(`function ${functionName}(${generateBuilderArgs(type).join(', ')}): NodeSchema<t.${type}> {
  return { type: '${type}', ${generateBuilderProperties(type).join(', ')} };
}
`);
}

out.close();

function toFunctionName(typeName: string): string {
  return typeName.replace(/^(TS|JSX|[A-Z])/, (match) => match.toLowerCase());
}

function generateBuilderArgs(type: string): string[] {
  const fields = t.NODE_FIELDS[type];
  const fieldNames = sortFieldNames(Object.keys(t.NODE_FIELDS[type]), type);
  const builderNames = t.BUILDER_KEYS[type];

  const args: string[] = [];

  fieldNames.forEach((fieldName) => {
    const field = fields[fieldName];
    let typeAnnotation = stringifyValidator(field.validate, 't.');

    if (isNullable(field) && !hasDefault(field)) {
      typeAnnotation += ' | null';
    }

    if (builderNames.includes(fieldName)) {
      const bindingIdentifierName = t.toBindingIdentifierName(fieldName);
      const arg = `${bindingIdentifierName}?: Schema<${typeAnnotation}>`;
      args.push(arg);
    }
  });

  return args;
}

function generateBuilderProperties(type: string): string[] {
  const builderKeys = sortFieldNames(t.BUILDER_KEYS[type], type);
  return builderKeys.map((key) => {
    const argName = t.toBindingIdentifierName(key);
    return argName === key ? key : `${key}: ${argName}`;
  });
}

function hasDefault(field: t.FieldOptions): boolean {
  return field.default != null;
}

function isNullable(field: t.FieldOptions): boolean {
  return field.optional || hasDefault(field);
}

function sortFieldNames(fields: string[], type: string): string[] {
  return fields.sort((fieldA, fieldB) => {
    const indexA = t.BUILDER_KEYS[type].indexOf(fieldA);
    const indexB = t.BUILDER_KEYS[type].indexOf(fieldB);
    if (indexA === indexB) return fieldA < fieldB ? -1 : 1;
    if (indexA === -1) return 1;
    if (indexB === -1) return -1;
    return indexA - indexB;
  });
}

export default function stringifyValidator(
  validator: Validator | undefined,
  nodePrefix: string,
): string {
  if (validator === undefined) {
    return 'any';
  }

  if ('each' in validator) {
    return `Array<${stringifyValidator(validator.each, nodePrefix)}>`;
  }

  if ('chainOf' in validator) {
    const ret = stringifyValidator(validator.chainOf[1], nodePrefix);
    return Array.isArray(ret) && ret.length === 1 && ret[0] === 'any'
      ? stringifyValidator(validator.chainOf[0], nodePrefix)
      : ret;
  }

  if ('oneOf' in validator) {
    return validator.oneOf.map((v) => JSON.stringify(v)).join(' | ');
  }

  if ('oneOfNodeTypes' in validator) {
    return validator.oneOfNodeTypes.map((_) => nodePrefix + _).join(' | ');
  }

  if ('oneOfNodeOrValueTypes' in validator) {
    return validator.oneOfNodeOrValueTypes
      .map((_) => {
        return isValueType(_) ? _ : nodePrefix + _;
      })
      .join(' | ');
  }

  if ('type' in validator) {
    return validator.type;
  }

  return 'any';
}

/**
 * Heuristic to decide whether or not the given type is a value type (eg. "null")
 * or a Node type (eg. "Expression").
 */
export function isValueType(type: string) {
  return type.charAt(0).toLowerCase() === type.charAt(0);
}
